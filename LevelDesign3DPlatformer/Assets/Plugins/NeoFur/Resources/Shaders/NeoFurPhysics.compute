#pragma kernel NeoFurPhysics

//input vert
struct NeoVertex
{
	float3	Position;
	float3	Normal;
	float4	Tangent;

	float2	UV0;

	//no byte types, will have to change in C# struct
	int4	InfluenceBones;
	float4	InfluenceWeights;

	float3	CombedDirectionAndLength;
};

//for morphs
struct BlendVertex
{
	float3	Position;
	float3	Normal;
	float3	Tangent;
};

struct ControlPoint
{
	float3	Position;
	float3	Velocity;
};

//input buffers
StructuredBuffer<NeoVertex>		Verts;
StructuredBuffer<float4x4>		Bones;
StructuredBuffer<BlendVertex>	Blends;
StructuredBuffer<float>			BlendWeights;	//weights + radial force stuff

//output buffer
RWStructuredBuffer<ControlPoint>	ControlPoints;

//usual shadey constants
float	In_ShellDistance;
int		NumVerts;
int		mbSkinned;		//0static 1skinned
int		NumBlends;		//number of morphs
int		NumRadialForces;

//I had several values here that I don't need anymore
//however removing them caused everything below to go totally haywire.
//I discovered through hours of raw random experimentation that I needed
//a dummy value here to keep that from happening.  Bug in the compiler I guess.
float	Dummy;

//transform deltas
float3	DeltaPos;
float3	DeltaRot0;
float3	DeltaRot1;
float3	DeltaRot2;
float3	DeltaScale;

//physics stuff
float	VelocityInfluence;
float	SpringLenStiff;
float	SpringAngleStiff;
float	SpringDampMult;
float	GravityInfluence;
float	AirResistMult;
float	MaxStretchDist;
float	MinStretchDist;
float	MaxRotNorm;
float	RadialForceInfluence;
float	WindInfluence;
float3	LocalGravityVec;
float	In_DeltaTime;
float3	WindVector;			//direction and power of wind force
float	GustFactor;			//additional power if a gust is active

// OBFUSCATE_START

float4x4 GetSkinXForm(int4 bnIdxs, float4 bnWeights)
{
	float4x4 skinTransform	=Bones[bnIdxs.x] * bnWeights.x;

	skinTransform	+=Bones[bnIdxs.y] * bnWeights.y;
	skinTransform	+=Bones[bnIdxs.z] * bnWeights.z;
	skinTransform	+=Bones[bnIdxs.w] * bnWeights.w;
	
	return	skinTransform;
}

//skin transform vert data
void ComputeSkin(int4 boneIdx, float4 weights,
	inout float3 position, 
	inout float3 norm,
	inout float3 splineDir,
	inout float3 tan)
{
	//do the bone influences
	float4x4 skinTransform	=GetSkinXForm(boneIdx, weights);

	float4	pos	=float4(position, 1);

	pos			=mul(skinTransform, pos);
	norm		=mul(skinTransform, norm);
	splineDir	=mul(skinTransform, splineDir);
	tan			=mul(skinTransform, tan);

	position	=pos.xyz / pos.w;
}

void MaxAngleClamp(float3 vertPos, float3 normalizedSplineDir, inout float3 cpPos)
{
	float	maxRads		=MaxRotNorm * 3.14159 / 180.0;
	float3	cpOffset	=(cpPos - vertPos);
	float	offsetLen	=length(cpOffset);
	if(offsetLen < 0.0001)
	{
		return;	//close to vert, can't vary angle much
	}

	float3	normalizedOffset	=cpOffset / offsetLen;

	float	d	=dot(normalizedSplineDir, normalizedOffset);
	if(d > 0.999)
	{
		return;	//acos gets nannish near 1
	}
	float	ang	=acos(d);
	if(ang <= maxRads)
	{
		return;
	}

	float3	goodVec	=lerp(normalizedSplineDir, normalizedOffset, maxRads / ang);

	// Restore the length of the original offset.
	goodVec	=normalize(goodVec);
	goodVec	*=offsetLen;

	cpPos	=goodVec + vertPos;
}

void MinMaxDistanceClamp(float3 vertPos, float splineLength, inout float3 cpPos)
{
	float3	cpVec	=cpPos - vertPos;

	float	dist	=length(cpVec);
	float	maxDist	=splineLength * MaxStretchDist;
	float	minDist	=splineLength * MinStretchDist;

	if(dist > maxDist)
	{
		float3	newOffset	=(cpVec / dist) * maxDist;
		cpPos				=vertPos + newOffset;
	}
	else if(dist < minDist)
	{
		float3	newOffset	=(cpVec / dist) * minDist;
		cpPos				=vertPos + newOffset;
	}
}

float3 SpringSim(float3 vertPos, float3 cpPos,
				 float3 normalizedSplineDir, float splineLength)
{
	//spring sim
	float3	TotalSpringForce	=0;

	//spring length stuff
	float3	SpringVector	=cpPos - vertPos;
	float	SpringLength	=length(SpringVector);
	if(SpringLength > 0.01f)
	{
		//linear spring
		float	SpringRestLength	=splineLength;
		float	SpringOffset		=SpringRestLength - SpringLength;
		float	SpringStiffness		=SpringLenStiff;
		float	SpringForce			=SpringStiffness * SpringOffset;

		TotalSpringForce	+=(SpringVector / SpringLength) * SpringForce;

		//torsion spring
		float	dp			=dot(SpringVector / SpringLength, normalizedSplineDir);
		float	AngleOffset	=0.0;
		if(dp < 1)
		{
			AngleOffset	=acos(dp);
		}

		float	AngleSpringStiffness	=SpringAngleStiff;
		if(AngleOffset > 0.01f)
		{
			float3	vTarget	=vertPos + normalizedSplineDir * splineLength;

			float3	AngleSpringReturnForceDirection	=vTarget - cpPos;

			AngleSpringReturnForceDirection	=normalize(AngleSpringReturnForceDirection);

			float3	FinalReturnVelocity	=AngleSpringReturnForceDirection * In_DeltaTime * AngleSpringStiffness * AngleOffset;

			//clamp to max required velocity to get to rest position this frame
			if(SpringLength < (length(FinalReturnVelocity) * In_DeltaTime))
			{
				FinalReturnVelocity	=(vTarget - cpPos) / In_DeltaTime;
			}
			TotalSpringForce	+=FinalReturnVelocity / In_DeltaTime;
		}
	}
	return	TotalSpringForce;
}

void TransformInfluence(float3 skinPos, inout float3 cpVel)
{
	//positional delta rotated into local / skin space
	cpVel	-=DeltaPos * VelocityInfluence;

	//rotational delta
	float3	rotDelta	=0;
	rotDelta.x	=dot(DeltaRot0, skinPos);
	rotDelta.y	=dot(DeltaRot1, skinPos);
	rotDelta.z	=dot(DeltaRot2, skinPos);

	//subtract out position to leave the delta
	rotDelta	-=skinPos;

	cpVel	-=rotDelta * VelocityInfluence;

	//scale delta
	float3	deltaScale	=skinPos * DeltaScale;

	deltaScale	-=skinPos;

	cpVel	-=deltaScale * VelocityInfluence;
}

void RadialForce(float3 cpPos, inout float3 cpVel)
{
	for(int k = 0; k < NumRadialForces; k++)
	{
		float3	RadialForceVector	=cpPos - float3(
			BlendWeights[NumBlends + (k * 5)],
			BlendWeights[NumBlends + (k * 5) + 1],
			BlendWeights[NumBlends + (k * 5) + 2]);

		float	RadialForceDistance	=length(RadialForceVector);
		float	RadialRadius		=BlendWeights[NumBlends + (k * 5) + 3];
		float	RadialPower			=BlendWeights[NumBlends + (k * 5) + 4];

		if(RadialForceDistance <= RadialRadius)
		{
			float	RadialForceScale	=1.0 - (RadialForceDistance / RadialRadius);

			RadialForceVector	/=RadialForceDistance;

			cpVel	+=RadialForceVector *
				RadialForceScale * RadialForceInfluence * RadialPower;
		}
	}
}

//apply morph deltas to vert data
void Morph(int idx, inout float3 vertPos, inout float3 norm, inout float4 tan)
{
	if(NumBlends <= 0)
	{
		return;
	}

	float3	posDiff		=0;
	float3	normDiff	=0;
	float3	tanDiff		=0;

	for(int blend=0;blend < NumBlends;blend++)
	{
		float	weight	=BlendWeights[blend];

		float3	morphPos	=Blends[idx + (blend * NumVerts)].Position;
		float3	morphNorm	=Blends[idx + (blend * NumVerts)].Normal;
		float3	morphTan	=Blends[idx + (blend * NumVerts)].Tangent;

		posDiff		+=(morphPos * weight);
		normDiff	+=(morphNorm * weight);
		tanDiff		+=(morphTan * weight);
	}

	vertPos	+=posDiff;
	norm	+=normDiff;
	tan.xyz	+=tanDiff;

	//renormalize
	norm	=normalize(norm);
	tan.xyz	=normalize(tan.xyz);
}


//Tried a stress, and 1 1 1 really seems to be the best
//with a lot of furs on screen.  Not sure why.
[numthreads(1, 1, 1)]
void NeoFurPhysics(uint3 id : SV_DispatchThreadID)
{
	float3	norm, splineDir;
	float4	tan;

	float3	skinPos;
	float3	cpPos	=ControlPoints[id.x].Position;
	float3	cpVel	=ControlPoints[id.x].Velocity;

	skinPos		=Verts[id.x].Position;
	norm		=Verts[id.x].Normal;
	splineDir	=Verts[id.x].CombedDirectionAndLength;
	tan			=Verts[id.x].Tangent;

	//morphs go first
	Morph(id.x, skinPos, norm, tan);

	if(mbSkinned)
	{
		ComputeSkin(Verts[id.x].InfluenceBones, Verts[id.x].InfluenceWeights,
			skinPos, norm, splineDir, tan.xyz);
	}

	float3	SkinnedFinalSplineDir	=splineDir;
	float	SplineLength			=length(splineDir) * In_ShellDistance;
	float3	NormalizedSplineDir		=normalize(SkinnedFinalSplineDir);

	// Velocity as a result of the different transform.
	// --------------------------------------------------------------------
	// General velocity "fudge". Not realistic, but makes it look stiff by
	// faking it.
	TransformInfluence(skinPos, cpVel);

	// TODO: Velocity needs to be transformed too!
	// Spring simulation.
	// --------------------------------------------------------------------
	float3	TotalSpringForce	=SpringSim(skinPos, cpPos, NormalizedSplineDir, SplineLength);

	cpVel	+=TotalSpringForce * In_DeltaTime * SpringDampMult;

	// Gravity
	// --------------------------------------------------------------------
	cpVel += GravityInfluence * In_DeltaTime * LocalGravityVec;

	// Radial force effects. (TODO: Incomplete!)
	// --------------------------------------------------------------------
	RadialForce(cpPos, cpVel);

	// Wind
	// --------------------------------------------------------------------		

	float3 windVec = WindVector * In_DeltaTime * WindInfluence;
	cpVel += windVec;

	//doesn't work exactly like unreal
	//the wind generators are different, and unity's is a black box
	//the sin thing isn't working for me
	//try a tangent perturb thing
	//TODO: see if possible to re-use this basis in angle clamp below
	float3		biNormal	=cross(normalize(norm), normalize(tan.xyz)) * tan.w;
	float3x3	rotMat		=float3x3(tan.xyz, biNormal, norm);
	float		windLen		=length(windVec);

	//this is all probably a bit overkill?
	cpVel	+=mul(rotMat,
		float3(sin(GustFactor * 5),
		cos(GustFactor * 10), 0)) * GustFactor * 0.02;

	// "Air Resistance" Dampening - Deceleration proportional to velocity.
	// --------------------------------------------------------------------

	cpVel *= AirResistMult;

	// Finally, apply the velocity to the particle's position.
	// --------------------------------------------------------------------

	if(!isnan(cpPos.x) && !isnan(cpPos.y) && !isnan(cpPos.z) &&
		isfinite(cpPos.x) && isfinite(cpPos.y) && isfinite(cpPos.z)) 
	{
		cpPos += cpVel * In_DeltaTime;
	} else {
		cpPos = float3(0.0, 0.0, 0.0);
	}

	// Max distance clamp.
	// --------------------------------------------------------------------
	MinMaxDistanceClamp(skinPos, SplineLength, cpPos);

	//Max angle clamp
	MaxAngleClamp(skinPos, NormalizedSplineDir, cpPos);

	// Write control point for next frame.
	// --------------------------------------------------------------------
	ControlPoints[id.x].Position	=cpPos;
	ControlPoints[id.x].Velocity	=cpVel;
}
